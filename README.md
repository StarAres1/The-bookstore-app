[Ссылка на видео с ютуба](https://www.youtube.com/watch?v=SEvR78OhGtw)

# Краткая вводная информация
VCS - Version Control System (система контроля версий)
централизованные (centralized) (полная история лежит только на удаленном сервере) и распределенные VSC. Можно комбинировать. Git - распределенная (distributd) система контроля версий.

Commit - "снимок" состояния проекта. Запоминаются все измененны файлы, а если файл не менялся, то подтягивается ссылка из предыдущего commit. Возможен и другой вариант хранения версий (но он не использется в Git), когда хранятся только исходные файлы и изменения, которые на них накладываются в каждой версии

Хэш сумма: легко можно вычислить при исходных данных результат, а наоборот либо очень сложно, либо вообще невозможно. При незначительных изменениях входных данных (даже одного бита) результаты будут совершенно разными.

При создании commit вычисляется его хэш сумма. В каждом  commit хранится хэш сумма предыдущего => подменить предщий commit практически невозможно.

# Начальная настройка Git
## Флаги для команд
system - настройки для всех пользователей системы
global - настройки применяются к пользователю системы
local - настройки для текущего репозитория
## Команды для настройки
git config --global user.name "LordRuller"
git config -- global user.email lord@yandex.ru

# Первые команды
mkdir nameOfFolder - создание папки
cd nameOfFolder - зайти в папку
cd .. - поднятся на каталог выше
ls -la - отобразит все содержимое папки (l - флаг, которой выведет всё списком, a - флаг для вывода всех скрытх объектов)
git init - создание репозитория (подключения git)
touch nameOfFile.extension - создание файла с указанным расшрением
 git log - история проекта (p - более подробный вывод commit)
 git status - показывает состояние всех файлов

## Состояния файла в проекте
tracked (modified (файл изменен) => staged (файл подготовлен к записи и находится в staging area или по-другому называется index) => commited (файл сохранен))
untracked

## Команды для создания commit
git nameOfFolderOrFile - добавит файл или папку в index (названия можно вводить через пробел)
git commit -m "Message" - создание commit из файлов, находящихся в index (m - краткое сообщение, что было изменено)

## Основные команды
git show HashCommit - покажет детально данные об этом commit
vim app.py - откроет файл в консоли (для закрытия нажми Esc далее напиши 
:x(сохранит изменения и выйдет)
:w (только соранит данные)
:q (выйдет без сохранения)) (нажатие кнопки a позволяет редактировать документ)

git restore app.py - откат файл на состояние последнего commit
git diff app.py -  показывает изменения в файле с момента последнего commit
git diff --staged - изменения которые находятся в index

git commit -am "Message" -  commit (все файлы под версионным контролем попадают в  index, а затем в commit)
git mv app.py  application.app -  переименование файла или перенос файла в другой каталог (под капото сразу применяется команда add)
git rm - удаление файла (--cached - делает изменение в commit, но переводит файл в статус untrackted и не трогает его)

 git restore --staged File -  забирает файл из index назад

# GitIgnore
Создаем файл в репозитории с паттернами для игнорирования определенных файлов. 
Называем этот файл .gitignore
Пример:
 # комментарий
 __pycache__/
 *.py[cod] #  один из символов в скобках*
 docker.yaml
 log/
 tt/pp
По сути используются упрощенные регулярные выражения

#  Ветвление
##  Указатели
Существует указатель HEAD указывает на commit на котором сейчас ведется работа. У каждой ветки есть свой указатель, который ссылается на её последний commit

git branch newName - создание новой ветки
git checkout  newName -перенести указатель HEAD на другую ветку

В ветки master всегда должен быть рабочий стабилный код

git branch -a -  позволяет посмотреть какие есть ветки в репозитории
git merge newBranch - мержим ветку, на которой находимся сейчас, с веткой newBranch

fastforward - если ветка была прямым продолжением изначальной, то просто передвигается ее указатель

git branch -d newBranch - удаление ненужной ветки (обычно используется после merge) (по факту удаляется просто указатель)

После  merge в commit сохранятются хэши на два предшетсвующих commit (commit слияния или merge-commit)``

# Перемещение между commit
git checkout Hash - по хэшу перемещаем указатель HEAD на нужный нам commit (указатели веток остаются на местах) (при вызове команды git log будет надпись HEAD detached. нужно быть осторожным при создании commit в этот момент, так как он не бдет принадлежать ни одной ветке) 

git checkout -b newBranch Hash -  создам новый commit от укзанного хэша и переносим указатель HEAD на новую ветку (аргументы опциональны)

git checkout file.py - откат файл на состояние последнего commit в этой ветке

# Перемещение указателей веток
git reset --hard Hash -  передвигается укзатель ветки и указатель HEAD, при этом все правки и index игнорируются. 

Удаляется только указатель, commit устаются и их потом можно найти по хэшу или как-то иначе

# Работа с удаленными репозиториями

HTTPS - нужно логиниться в GitHub
SSH -  не нужно логиниться, но нужна дополнительная настройка на компе
*Почему-то SSH лучше, надо будет раозбраться в это)))*
git remote -v - сервера для отправки и получения

 git remote add origin LINK - полдключение к удаленному репозиторию (origin - устоявшееся имя репозитория, если он один в проекте)
 git push origin master - отправить изменения на сервер origin в ветку master с ветки на которой я сейчас нахожусь
 git clone LINK -  копирование репозитория себе на комп
 git push origin master - засылаем commit
 git pull origin master - забираем изменения с сервера

На удаленке есть свой укзатель (ветка слежения / remote reference)  remotes/origin/master. Его мы никак перемещать не можем

 git fetch -  можно в случае нескольких репозиторием написать его название (например, origin) этой командой узнаем расположение указтеля на удаленке, наши локальные commit не будут тронуты. Мы скачаем недостающие commit и передвинет ветки слежения
По сути git pull  выполняет команды  git fetch и git merge origin/master

git push --set--upstream origin master -   свяжет локальную ветку с удаленной.  Далее можно будет писать только команду  git push без дополнительных аргументов

Локальная ветка другого разработчика загруженная на GitHub не будет копироваться к нам, но мы будем об этом знать и сможем при необходимости перейти на неё и скопировать ее при помощи git checkout nameBranch

# Страшно))) Rebase...
 Лучше пока сюда не лезть. Можно всё устроить полную хрень. Попозже это вернуться сюда
 
# Git tag
легковесные тэги - указатель с именем, которое мы ему дали
 git tag name
 
аннотированные тэги - есть хэш, автор, дата и т.д.
git tag -a name -m "message"

git tag - просмотреть тэги

Тэги по умолчанию не отправляются на сервер, это делается явно

 git push origin nameOfTag
или сразу все тэги
git push --tags
